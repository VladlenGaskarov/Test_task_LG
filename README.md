Вопрос №1
Реализация через целочисленное деление на 2 более понятна рядовому программисту, но для процессора она будет преобразована в умножение.
Реализация через логическое умножение быстрее работает, т.к. это битовая операция.

Вопрос №2
Для начала я бы хотел оговорить, что намеренно не прописал проверки на переполнение и пустоту массива, т.к. они замедляют работу функций, но для реального проекта такие проверки считаю обязательными.
Первая реализация будет работать медленее, чем вторая, т.к. в ней используется append, но при этом массив динамически изменяется, за счет чего требует меньше памяти.
Во второй реализации я использую вставки по индексу, такие вставки происходят за время O(1), плюс заранее выделяю память на массив, что токже способствует быстродействию.

Вопрос №3
В реальной работе я бы предпочел использовать sort, либо sorted. Очевидно, что мой алгоритм не будет самым быстрым для всех случаев,
т.к. существует несколько видов быстрой сортировки под разные случаи. При этом сложность в худшем случае O(n^2),
а у алгоритма сортировки слиянием O(n log n), но в среднем случае у обоих способов O(n log n), однако,
быстрая сортировка при среднем случае работает быстрее именно по процессорным тикам.
При большем количестве входных данных, можно было бы использовать проверку на отсортированность в начале функции.
